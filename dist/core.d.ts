export declare type Parser<T, S> = (target: T, position: number) => [boolean, S, number, string?];
export declare function seq<T, P0, P1>(...parsers: [Parser<T, P0>, Parser<T, P1>]): Parser<T, [P0, P1]>;
export declare function seq<T, P0, P1, P2>(...parsers: [Parser<T, P0>, Parser<T, P1>, Parser<T, P2>]): Parser<T, [P0, P1, P2]>;
export declare function seq<T, P0, P1, P2, P3>(...parsers: [Parser<T, P0>, Parser<T, P1>, Parser<T, P2>, Parser<T, P3>]): Parser<T, [P0, P1, P2, P3]>;
export declare function seq<T, P0, P1, P2, P3, P4>(...parsers: [Parser<T, P0>, Parser<T, P1>, Parser<T, P2>, Parser<T, P3>, Parser<T, P4>]): Parser<T, [P0, P1, P2, P3, P4]>;
export declare function seq<T, P0, P1, P2, P3, P4, P5>(...parsers: [Parser<T, P0>, Parser<T, P1>, Parser<T, P2>, Parser<T, P3>, Parser<T, P4>, Parser<T, P5>]): Parser<T, [P0, P1, P2, P3, P4, P5]>;
export declare function seq<T, P0, P1, P2, P3, P4, P5, P6>(...parsers: [Parser<T, P0>, Parser<T, P1>, Parser<T, P2>, Parser<T, P3>, Parser<T, P4>, Parser<T, P5>, Parser<T, P6>]): Parser<T, [P0, P1, P2, P3, P4, P5, P6]>;
export declare function seq<T, P0>(...parsers: Parser<T, P0>[]): Parser<T, P0[]>;
export declare function or<T, S>(...parsers: Parser<T, S>[]): Parser<T, S>;
export declare function or<T, P0, P1>(...parsers: [Parser<T, P0>, Parser<T, P1>]): Parser<T, P0 | P1>;
export declare function or<T, P0, P1, P2>(...parsers: [Parser<T, P0>, Parser<T, P1>, Parser<T, P2>]): Parser<T, P0 | P1 | P2>;
export declare function or<T, P0, P1, P2, P3>(...parsers: [Parser<T, P0>, Parser<T, P1>, Parser<T, P2>, Parser<T, P3>]): Parser<T, P0 | P1 | P2 | P3>;
export declare function or<T, P0, P1, P2, P3, P4>(...parsers: [Parser<T, P0>, Parser<T, P1>, Parser<T, P2>, Parser<T, P3>, Parser<T, P4>]): Parser<T, P0 | P1 | P2 | P3 | P4>;
export declare function or<T, P0, P1, P2, P3, P4, P5>(...parsers: [Parser<T, P0>, Parser<T, P1>, Parser<T, P2>, Parser<T, P3>, Parser<T, P4>, Parser<T, P5>]): Parser<T, P0 | P1 | P2 | P3 | P4 | P5>;
export declare const lazy: <T, S>(generator: () => Parser<T, S>) => Parser<T, S>;
export declare const opt: <T, S>(parser: Parser<T, S>) => Parser<T, S>;
export declare const many: <T, S>(parser: Parser<T, S>) => Parser<T, S[]>;
export declare const map: <T, S, U>(parser: Parser<T, S>, transform: (value: S) => U) => Parser<T, U>;
export declare const transform: <T, S, U>(transformParser: Parser<T, S>, parser: Parser<S, U>) => Parser<T, U>;
export declare const fail: Parser<any, null>;
export declare const pass: <T>(target: T[], position: number) => [boolean, T, number, string?];
export declare const seqMap: <T, S, R>(parser: Parser<T, S>, next: (value: S) => Parser<T, R>) => Parser<T, R>;
export declare const vec: <T, S>(parser: Parser<T, S>, size: number) => Parser<T, S[]>;
export declare const terminate: <S, T>(result: T) => Parser<S, T>;
